import hashlib
import os
import random
import shutil
import numpy as np
from collections import OrderedDict

import gymnasium as gym
from gymnasium import spaces

import pathlib

from malware_gym.envs.utils import read_file, predict
from malware_gym.envs.feature_extractor import pefeature
from malware_gym.envs.action import manipulate2 as manipulate

ACTION_LOOKUP_TABLE = {i: act for i, act in enumerate(manipulate.ACTION_TABLE.keys())}


class MalwareEnv(gym.Env):
    metadata = {"render_modes": ["human"]}

    def __init__(
        self,
        samples_dir,
        original_samples_path,
        output_path,
        modified_samples_path,
        maxturns=10,
    ):
        self.action_space = spaces.Discrete(len(ACTION_LOOKUP_TABLE))
        self.maxturns = maxturns
        self.feature_extractor = pefeature.PEFeatureExtractor2()
        self.action_history = OrderedDict()
        self.samples_path = [
            sample
            for sample in pathlib.Path(samples_dir).glob("**/*")
            if sample.is_file()
        ]
        self.sample = None
        self.output_path = output_path
        self.save_modified_samples = modified_samples_path
        self.original_samples_path = original_samples_path

        self.obs_dim = (2350,)
        # self.observation_space = spaces.Box(
        #     low=np.zeros(self.obs_dim), high=np.ones(self.obs_dim), dtype=np.float64
        # )
        self.observation_space = spaces.Box(
            low=np.full(shape=self.obs_dim, fill_value=np.NINF),
            high=np.full(shape=self.obs_dim, fill_value=np.Inf),
            shape=self.obs_dim,
            dtype=np.float64,
        )
        self.reset()
        pass

    def reset(self, seed=None, options=None):
        super().reset()
        self.turns = 0

        while True:
            # get random sample
            self.current_sample_path = random.choice(self.samples_path)
            self.sample = read_file(self.current_sample_path)

            self.action_history[self.current_sample_path] = {
                "actions": [],
                "evaded": False,
            }
            label = predict(self.sample)
            if label == "Benign":
                continue

            self.current_state = self.feature_extractor.extract(self.sample)

            break

        return (self.current_state, {None: None})

    def step(self, action):
        self.turns += 1
        self._take_action(action)
        reward = 0

        try:
            self.label = predict(self.sample)
        except Exception as e:
            print(e)
            print("Classification failure")
            episode_over = True
        else:
            self.current_state = self.feature_extractor.extract(self.sample)
            if self.label == "Benign":
                reward = 1
                episode_over = True
                self.action_history[self.current_sample_path]["evaded"] = True
                m = hashlib.sha256()
                m.update(self.sample)
                sha256 = m.hexdigest()
                self.action_history[self.current_sample_path]["sha256"] = sha256

                # save modified sample
                with open(os.path.join(self.save_modified_samples, sha256), "wb") as f:
                    f.write(self.sample)

                # copy original sample to original_samples_path
                shutil.copy(self.current_sample_path, self.original_samples_path)

            elif self.turns >= self.maxturns:
                reward = 0
                episode_over = True
            else:
                reward = 0
                episode_over = False
        if episode_over:
            print("Episode over, reward = {}".format(reward))

        return self.current_state, reward, episode_over, False, {}

    def _take_action(self, action):
        assert action < len(ACTION_LOOKUP_TABLE)
        action = ACTION_LOOKUP_TABLE[action]
        print(action)
        self.action_history[self.current_sample_path]["actions"].append(action)
        self.sample = bytes(manipulate.modify_without_breaking(self.sample, [action]))

        pass

    def render(self):
        pass
